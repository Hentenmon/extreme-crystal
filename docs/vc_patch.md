# 2DS/3DS Nintendo Virtual Console Patch

## Summary

A virtual console `.patch` file may be generated for the purposes of including in a Nintedo 2DS/3DS Virtual Console (VC) `.cia`. The `.patch` file is used by the VC in order to determine when and under what conditions to enable certain Virtual Console functionalities, such as the Wireless Link capabilities. It also tells the Virtual Console what parts of the game it should patch during runtime, such as disabling the gameboy printer features. Building or obtaining a `.cia` file is outside the scope of this project.

## Building the `.patch`

Building a `.patch` file may be accomplished by entering the following command:

    `make crystalvc` 

After the command completes you should have a `pokecrystalvc.patch` file in your pokecrystal directory that you may use to include in your `.cia` build.

## Key Files of Note:

#### The `patch.template` File

The `pokecrystalvc.patch.template` file located under `vc/` is used by `tools/make_patch` in order to generate a `.patch` file. This file is an argument for `make_patch`. This file was abstracted from an offical .patch file used in the Pokemon Crystal US release for the Virtual Console. It contains both original content (comments, headings, ect.) as well as abstracted **Commands** that are used by `make_patch` to build an identical `.patch` to the original release.

#### The `constants.out` File

The `pokecrystalvc.constants.out` file located under `vc/` is generated by `MakeFile` and is used to store the constants and their values from a `PRINTLN` output generated in `pokecrystalvc.constants.asm`. This file is an argument for `make_patch`.

#### The `cosntants.asm` File

The `pokecrystalvc.cosntants.asm` file located under `vc/` is used to output the values of required constants referenced in the `patch.template`. It utilizes an `INCLUDE "constants.asm"` as well as a `vc_const: MACRO` to output constant values. If you add new constants or rename existing ones in `patch.template` you will need to add or update the constants in this file.

#### The `vc.gbc` File

The `pokecrystalvc.gbc` file generated by `MakeFile` is used by `make_patch` to compare against the original `pokecrystal11.gbc` for the purposes of identifying code differences between a `.VC_<PatchNameHere>::` symbol and a corresponding ending symbol `.VC_<PatchNameHere>_End::`. It is also used in a last comparison function in `make_patch` to verify that all differences have been captured in the `.patch` file. It is **NOT** inteded to be used in the `.cia` file. `pokecrystal11.gbc` should be used for the `.cia` file.

#### The `vc.sym` File

The `pokecrystalvc.sym` file is a normal `.sym` file except it contains extra `._VC` labels used by `make_patch` in identifying patch and hook locations. The codebase contains `vc_hook`, `vc_patch`, and `vc_patch_end` macros used to conditionally generate the `._VC` labels.  

#### The `make_patch` File

The compiled `make_patch` file located under `tools/` is used by `MakeFile` to build the `.patch` file. It has the following usage:

    `make_patch labels.sym constants.out patched.gbc original.gbc vc.patch.template vc.patch`

A typical execution from the `MakeFile` looks like:

    `tools/make_patch pokecrystalvc.sym vc/pokecrystalvc.constants.out pokecrystalvc.gbc pokecrystal11.gbc vc/pokecrystalvc.patch.template pokecrystalvc.patch`

## `make_patch` Execution

1. The `make_patch` begins by parsing every symbol in `pokecrystalvc.sym` as well as every constant in `pokecrystalvc.constants.out`. 

2. The `pokecrystalvc.patch.template` is then read character by character in the `process_template` function. 
   
   1. It checks for comments. If a `;` is encountered, it outputs all characters until the next `\n` or `\r` directly to the `.patch` file.
   
   2. It checks for a patch name. If a `[` is encountered, it gathers all characters until the next `]`. Characters not in `A-Za-z0-9_@#` are converted to `_`s for these labels. `make_patch` then appends `.VC_` to the front of these characters and looks it up. Storing a match to be referenced later. It will also print these characters unmodified to the `.patch` file. All characters after `]` until the next `\n` or `\r` are also output to the `.patch` file.
   
   3. It checks for a Command. If a `{` is encountered, it gathers all characters until the next `}`. This check does `NOT` output `{`, `}`, or any of the charcters in between directly to the `.patch` file. Instead it interprets what to do in the function `interpret_command`. Afterwords, it then outputs all characters after `}` until the next `\n` or `\r` to the `.patch` file.
   
   4. It defaults to printing characters directly to the `.patch` file if it doesn't encounter any of the above conditions.

3. The`interpret_command` function takes in everything that was between a `{` and a `}` found in the `process_template` function. Commands are lexed like CLI arguments: Whitespace-seperated tokens, ignoring leading and trailing whitespace.
   `{  hex   @+1   4   }` is the same as `{hex @+1 4}`.  The first token is considered the actual Command. The rest are considered arguments. 
   
   A. Arguments may be any of the following:
   
   1. Comparisons such as `==`, `>`, `<`, `>=`, `<=`, `!=`, `||`.
   
   2. Anything starting with a `0-9` digit is assumed to be parsable by `strtol` with base 0 (i.e. decimal `42`, hex `0x2a`, or octal `052`).
   
   3. If the argument is none of the above, it must either be a `<name>+<offset>` or just `<name>`. `<name>` can be any sequence of non-`+` characters that's defined as a symbol; `<offset>` can be anything parsable by `strtol` with base 0.
   
   B. Commands may be any of the following:
   
   1. The `patch` command takes in the found symbol from the `[Patch Name]` in the process_template step, and searches for an additional symbol that ends with `_End`. It calculates the size of the patch by subtracting the offset of `._VC_<Patch_Name>::` from `._VC_<Patch_Name>_End::`. It also takes in one optional argument representing an _additional offset_ which it will add to `._VC_<Patch_Name>::`. It will then output `a%d:` where `%d` represents the calculated number of bytes in the patch. Afterwords it will seek to to the starting offset representing `._VC_<Patch_Name>::` + `<additional offset>` in both `pokecrystal11.gbc` and `pokecrystalvc.gbc`. It will print each byte, from the starting offset until it reaches the size of the patch, seperated by spaces, in lowecase hexadecimal.
   2. The `PATCH` command performs the same function as the `patch` command, except it prints each byte in uppercase hexadecimal.
   3. The `dws` command takes in any number of arguments that can be parsed in `Section A. Arguments` listed above. It will output `a%d:` where `%d` represents the number of arguments multiplied by 2. This is because each argument is seperated into two byte chunks or `DW`. It will then output the low byte followed by the high byte corresponding to the argument in lowercase hexadecimal. 
   4. The `DWS` command performs the same function as the `dws` command, except it prints each byte in uppercase hexadecimal.
   5. The `db` command takes in one argument that can be parsed in `Section A. Arguments` listed above. It will output `a1:` immediately followed by a single byte value in lowercase hexadecimal, corresponding to the argument, with no space in between `a1:` and the byte value.
   6. The `DB` command performs the same function as the `db` command, except it prints the byte in uppercase hexadecimal.
   7. The `hex` command takes in 1 required argument with a 2nd optional argument. The first argument is any argument can be parsed in `Section A. Arguments` listed above. The second argument is an optional padding argument used primarily when we expect a certain hexadecimal length, and apply leading zeros if the length is smaller than the padding. The command will output a hexadecimal value with a leading `0x`. Example: `0xfffff`
   8. The `Hex` command performs the same function as the `hex` command, except the low byte is lowercase and the rest is uppercase. Example: `0xFFFff`
   9. The `heX` command performs the same function as the `hex` command, except the low byte is uppercase and the rest is lowercase.  Example: `0xfffFF`
   10. The `hEX` command performs the same function as the `hex` command, except the Low three nibbles are uppercase, and the rest is lowercase. Example: `0xffFFF`
   11. The `HEX` command performs the same function as the `hex` command, except the output value is all uppercase. Example: `0xFFFFF`

4. The `verify_completeness` function runs last checking that all byte differences between the patched_rom and the orig_rom are accounted for in the patch file. If it finds a differing byte that is in an offset that does not correspond with a previous patch identified, it will error out the program with information detailing the mismatch.












